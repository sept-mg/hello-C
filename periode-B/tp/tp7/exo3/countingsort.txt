
/**
 * @brief Tri un tableau par ordre croissant en appliquant l'algorithme de tri 
 * par dénombrement (H. H. Seward, 1954). 
 * Attention, cet algorithme n'est efficace que si la plage de valeurs (i.e. la 
 * différence entre la plus grande et la plus petite) est limitée. Soit k la 
 * taille de cette plage, les complexités en temps et en espace sont en 
 * O(size + k).
 * @param[in,out] t : le tableau.
 * @param[in] size : la taille du tableau.
 */
void countingSort(int* t, int size) {
	// Point 1
	// détermination de la plus petite et la plus grande valeur présentes dans t
	...

	// Point 2
	// Allocation et initialisation d'un tableau de compteurs, un compteur par 
	// valeur possible
	...

	// Quelque soit i, tcpt[i] doit indiquer combien d'élements de t ont une 
	// valeur strictement inférieure à min + i.
  
	// Point 3
	// On commence par mettre dans tcpt[i] (le compteur de min + i) combien 
	// d'élements de t ont une valeur égale à min + i - 1 (la valeur juste 
	// inférieure).
	...

	// Point 4
	// Il suffit alors de cumuler les valeurs des compteurs
	....

	// Point 5 et 6
	// Création d'un nouveau tableau (tmp) et rangement des éléments de t dans  
	// le bon ordre. Quelque soit i, les élements de t ayant comme valeur min+i  
	// doivent être rangés à partir de l'indice tcpt[i].
	...
	// Il faut incrementer le compteur de façon à ce que le prochain
	// élement de t ayant la même valeur que t[i] soit placé à la bonne 
	// position.
	...
	}

	// Recopie du nouveau tableau dans t
	...
	// Désallocation mémoire
	...
}


